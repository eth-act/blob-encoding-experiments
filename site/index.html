<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blob Encoding Results</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { color: #333; }
        .summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .card h3 { margin: 0 0 10px 0; color: #666; font-size: 14px; }
        .card .value { font-size: 32px; font-weight: bold; color: #333; }
        .card .sub { color: #999; font-size: 14px; }
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #eee; }
        th { background: #333; color: white; font-weight: 500; }
        tr:hover { background: #f9f9f9; }
        .good { color: #22c55e; }
        .bad { color: #ef4444; }
        .neutral { color: #666; }
        .best { background: #dcfce7; }
        .error { color: #ef4444; padding: 20px; background: white; border-radius: 8px; }
        h2 { color: #333; margin-top: 30px; }
        .controls {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .controls select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-width: 200px;
        }
        .legend {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .legend h3 { margin: 0 0 15px 0; color: #333; }
        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .legend-section h4 {
            margin: 0 0 8px 0;
            color: #666;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .legend-section code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 13px;
        }
        .legend-section ul {
            margin: 0;
            padding-left: 0;
            list-style: none;
        }
        .legend-section li {
            margin: 4px 0;
            font-size: 14px;
            color: #555;
        }
        .legend-section li code {
            min-width: 100px;
            display: inline-block;
        }
        .legend-example {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        .legend-example code {
            background: #e8f5e9;
            color: #2e7d32;
        }
    </style>
</head>
<body>
    <h1>Blob Encoding Benchmark Results</h1>

    <div class="summary" id="summary"></div>

    <div class="legend">
        <h3>Strategy Legend</h3>
        <p style="margin: 0 0 15px 0; color: #666;">
            Strategies are named as <code>encoding + compression + packing</code>
        </p>
        <div class="legend-grid">
            <div class="legend-section">
                <h4>Encoding (tx list format)</h4>
                <ul>
                    <li><code>rlp</code> — RLP-encoded transaction list</li>
                    <li><code>ssz</code> — SSZ-encoded transaction list</li>
                    <li><code>rlp_pertx_*</code> — Each tx compressed individually, then RLP list</li>
                </ul>
            </div>
            <div class="legend-section">
                <h4>Compression</h4>
                <ul>
                    <li><code>none</code> — No compression (baseline)</li>
                    <li><code>snappy</code> — Fast, balanced compression</li>
                    <li><code>zstd_1</code> — Zstandard level 1 (fastest)</li>
                    <li><code>zstd_3</code> — Zstandard level 3</li>
                    <li><code>zstd_6</code> — Zstandard level 6</li>
                    <li><code>zstd_22</code> — Zstandard level 22 (max compression)</li>
                    <li><code>gzip_9</code> — Gzip level 9</li>
                </ul>
            </div>
            <div class="legend-section">
                <h4>Packing (blob field encoding)</h4>
                <ul>
                    <li><code>naive_31</code> — 31 bytes per 32-byte field element (simple, wastes 1 byte/element)</li>
                    <li><code>bitpack_254</code> — 254 bits per field element (BLS12-381 optimized)</li>
                </ul>
            </div>
        </div>
        <div class="legend-example">
            <strong>Example:</strong> <code>rlp_pertx_zstd_3+zstd_22+bitpack_254</code> means:
            compress each tx with zstd level 3, wrap in RLP list, then compress entire list with zstd level 22, then bitpack into blobs.
        </div>
    </div>

    <h2>Aggregate Results</h2>
    <table id="results">
        <thead>
            <tr>
                <th>Strategy</th>
                <th>Blobs</th>
                <th>vs Baseline</th>
                <th>Tx Raw</th>
                <th>Encoded</th>
                <th>Compressed</th>
                <th>Total Ratio</th>
                <th>Encode (ms)</th>
                <th>Decode (ms)</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <h2 style="margin-top: 40px;">Individual Block Results</h2>
    <div class="controls">
        <label>Filter by strategy:
            <select id="strategyFilter">
                <option value="">All strategies</option>
            </select>
        </label>
        <label style="margin-left: 20px;">Filter by block:
            <select id="blockFilter">
                <option value="">All blocks</option>
            </select>
        </label>
    </div>
    <table id="individual">
        <thead>
            <tr>
                <th>Block</th>
                <th>Strategy</th>
                <th>Blobs</th>
                <th>Tx Raw</th>
                <th>Encoded</th>
                <th>Compressed</th>
                <th>Efficiency</th>
                <th>Encode (ms)</th>
                <th>Decode (ms)</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <script>
        const baseline = { encoding: 'rlp', compression: 'none', packing: 'naive_31' };
        let allData = [];

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / 1024 / 1024).toFixed(2) + ' MB';
        }

        function aggregateResults(data) {
            const byStrategy = {};

            for (const r of data) {
                const key = `${r.encoding}+${r.compression}+${r.packing}`;
                if (!byStrategy[key]) {
                    byStrategy[key] = {
                        encoding: r.encoding,
                        compression: r.compression,
                        packing: r.packing,
                        blobs: 0,
                        txRawSize: 0,
                        encodedSize: 0,
                        compressedSize: 0,
                        encodeTime: 0,
                        decodeTime: 0,
                        count: 0
                    };
                }
                byStrategy[key].blobs += r.blob_count;
                // Support both old (raw_size) and new (tx_raw_size) field names
                byStrategy[key].txRawSize += r.tx_raw_size ?? r.raw_size;
                byStrategy[key].encodedSize += r.encoded_size ?? r.raw_size;
                byStrategy[key].compressedSize += r.compressed_size;
                byStrategy[key].encodeTime += r.encode_time_ms;
                byStrategy[key].decodeTime += r.decode_time_ms;
                byStrategy[key].count++;
            }

            return Object.values(byStrategy).map(s => ({
                ...s,
                encodeTime: s.encodeTime / s.count,
                decodeTime: s.decodeTime / s.count
            }));
        }

        function renderResults(data) {
            const aggregated = aggregateResults(data);
            const sorted = aggregated.sort((a, b) => a.blobs - b.blobs);

            const baselineData = aggregated.find(s =>
                s.encoding === baseline.encoding &&
                s.compression === baseline.compression &&
                s.packing === baseline.packing
            );
            const baselineBlobs = baselineData?.blobs || sorted[sorted.length - 1].blobs;

            // Summary cards
            const totalBlocks = data.length / aggregated.length;
            const bestStrategy = sorted[0];
            const savings = baselineBlobs - bestStrategy.blobs;

            document.getElementById('summary').innerHTML = `
                <div class="card">
                    <h3>BLOCKS ANALYZED</h3>
                    <div class="value">${totalBlocks}</div>
                    <div class="sub">${formatBytes(baselineData?.txRawSize || 0)} total tx data</div>
                </div>
                <div class="card">
                    <h3>BEST STRATEGY</h3>
                    <div class="value">${bestStrategy.compression}</div>
                    <div class="sub">${bestStrategy.encoding}+${bestStrategy.packing}</div>
                </div>
                <div class="card">
                    <h3>BLOB SAVINGS</h3>
                    <div class="value good">-${savings}</div>
                    <div class="sub">${((savings / baselineBlobs) * 100).toFixed(1)}% reduction vs baseline</div>
                </div>
                <div class="card">
                    <h3>BASELINE BLOBS</h3>
                    <div class="value">${baselineBlobs}</div>
                    <div class="sub">rlp+none+naive_31</div>
                </div>
            `;

            // Table
            const tbody = document.querySelector('#results tbody');
            tbody.innerHTML = sorted.map((s, i) => {
                const diff = s.blobs - baselineBlobs;
                const pct = ((diff / baselineBlobs) * 100).toFixed(1);
                const totalRatio = (s.txRawSize / s.compressedSize).toFixed(2);
                const isBest = i === 0;
                const diffClass = diff < 0 ? 'good' : (diff > 0 ? 'bad' : 'neutral');

                return `
                    <tr class="${isBest ? 'best' : ''}">
                        <td><strong>${s.encoding}+${s.compression}+${s.packing}</strong></td>
                        <td>${s.blobs}</td>
                        <td class="${diffClass}">${diff >= 0 ? '+' : ''}${diff} (${pct}%)</td>
                        <td>${formatBytes(s.txRawSize)}</td>
                        <td>${formatBytes(s.encodedSize)}</td>
                        <td>${formatBytes(s.compressedSize)}</td>
                        <td>${totalRatio}x</td>
                        <td>${s.encodeTime.toFixed(2)}</td>
                        <td>${s.decodeTime.toFixed(2)}</td>
                    </tr>
                `;
            }).join('');
        }

        function renderIndividual(data, strategyFilter = '', blockFilter = '') {
            let filtered = data;
            if (strategyFilter) {
                filtered = filtered.filter(r =>
                    `${r.encoding}+${r.compression}+${r.packing}` === strategyFilter
                );
            }
            if (blockFilter) {
                filtered = filtered.filter(r => r.payload_file === blockFilter);
            }

            const tbody = document.querySelector('#individual tbody');
            tbody.innerHTML = filtered.map(r => {
                const strategy = `${r.encoding}+${r.compression}+${r.packing}`;
                // Support both old and new field names
                const txRaw = r.tx_raw_size ?? r.raw_size;
                const encoded = r.encoded_size ?? r.raw_size;
                return `
                    <tr>
                        <td>${r.payload_file}</td>
                        <td><strong>${strategy}</strong></td>
                        <td>${r.blob_count}</td>
                        <td>${formatBytes(txRaw)}</td>
                        <td>${formatBytes(encoded)}</td>
                        <td>${formatBytes(r.compressed_size)}</td>
                        <td>${(r.space_efficiency * 100).toFixed(1)}%</td>
                        <td>${r.encode_time_ms.toFixed(2)}</td>
                        <td>${r.decode_time_ms.toFixed(2)}</td>
                    </tr>
                `;
            }).join('');
        }

        function populateFilters(data) {
            // Get unique strategies
            const strategies = [...new Set(data.map(r =>
                `${r.encoding}+${r.compression}+${r.packing}`
            ))].sort();

            // Get unique blocks
            const blocks = [...new Set(data.map(r => r.payload_file))].sort();

            const strategySelect = document.getElementById('strategyFilter');
            strategies.forEach(s => {
                const opt = document.createElement('option');
                opt.value = s;
                opt.textContent = s;
                strategySelect.appendChild(opt);
            });

            const blockSelect = document.getElementById('blockFilter');
            blocks.forEach(b => {
                const opt = document.createElement('option');
                opt.value = b;
                opt.textContent = b;
                blockSelect.appendChild(opt);
            });
        }

        function applyFilters() {
            const strategy = document.getElementById('strategyFilter').value;
            const block = document.getElementById('blockFilter').value;
            renderIndividual(allData, strategy, block);
        }

        document.getElementById('strategyFilter').addEventListener('change', applyFilters);
        document.getElementById('blockFilter').addEventListener('change', applyFilters);

        // Auto-load results.json
        fetch('results.json')
            .then(res => {
                if (!res.ok) throw new Error('Failed to load results.json');
                return res.json();
            })
            .then(data => {
                allData = data;
                renderResults(data);
                populateFilters(data);
                renderIndividual(data);
            })
            .catch(err => {
                document.getElementById('summary').innerHTML =
                    `<div class="error">Error: ${err.message}. Make sure results.json exists in the site folder.</div>`;
            });
    </script>
</body>
</html>
